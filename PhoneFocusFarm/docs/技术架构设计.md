# 手机专注农场应用 - 技术架构设计文档

## 1. 技术选型

### 1.1 开发语言和框架
- **开发语言**：Kotlin（100%）
- **UI框架**：Jetpack Compose（现代化声明式UI）
- **最低API级别**：API 29 (Android 10)
- **目标API级别**：API 34 (Android 14)

### 1.2 核心依赖库
```kotlin
// UI和动画
implementation "androidx.compose:compose-bom:2024.10.01"
implementation "androidx.compose.ui:ui"
implementation "androidx.compose.material3:material3"
implementation "androidx.compose.animation:animation"

// 3D渲染
implementation "androidx.compose.foundation:foundation"
implementation "androidx.graphics:graphics-core:1.0.0"

// 数据持久化
implementation "androidx.room:room-runtime:2.6.1"
implementation "androidx.room:room-ktx:2.6.1"
kapt "androidx.room:room-compiler:2.6.1"

// 依赖注入
implementation "com.google.dagger:hilt-android:2.48"
kapt "com.google.dagger:hilt-compiler:2.48"

// 协程和异步
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"

// 传感器和系统服务
implementation "androidx.core:core-sensors:1.0.0"

// 微信分享SDK
implementation 'com.tencent.mm.opensdk:wechat-sdk-android:6.8.0'
```

### 1.3 架构模式
- **整体架构**：MVVM + Clean Architecture
- **依赖注入**：Hilt
- **状态管理**：StateFlow + Compose State
- **数据流**：单向数据流（UDF）

## 2. 模块架构设计

### 2.1 模块划分
```
app/
├── core/                    # 核心功能模块
│   ├── timer/              # 计时器管理
│   ├── detector/           # 中断检测器
│   ├── permission/         # 权限管理
│   ├── data/               # 数据层
│   └── notification/       # 通知管理
├── feature-farm/           # 农场功能模块
│   ├── render/            # 3D渲染引擎
│   ├── entities/            # 游戏实体
│   ├── ai/                  # AI行为系统
│   └── interaction/        # 交互系统
├── feature-stats/          # 统计功能模块
│   ├── charts/             # 图表组件
│   ├── achievements/       # 成就系统
│   └── export/             # 数据导出
├── feature-share/          # 分享功能模块
│   ├── poster/             # 海报生成
│   └── wechat/             # 微信分享
└── common/                 # 公共模块
    ├── ui/                  # UI组件
    ├── utils/               # 工具类
    └── theme/               # 主题样式
```

### 2.2 核心模块详解

#### 2.2.1 Core模块
```kotlin
// 计时器状态机
sealed class TimerState {
    object Idle : TimerState()
    data class Incubating(
        val startTime: Long,
        val currentAnimal: AnimalType?,
        val progress: Float
    ) : TimerState()
    data class Interrupted(
        val reason: InterruptionReason,
        val duration: Long
    ) : TimerState()
    data class Completed(
        val duration: Long,
        val result: IncubationResult
    ) : TimerState()
}

// 中断检测器
interface InterruptionDetector {
    fun startMonitoring()
    fun stopMonitoring()
    val interruptionEvents: Flow<InterruptionReason>
}

// 专注模式
enum class FocusMode {
    STRICT,    // 严格模式
    NATURAL    // 自然模式
}

// 中断原因
enum class InterruptionReason {
    TOUCH_EVENT,           // 触摸事件
    APP_BACKGROUND,        // 应用后台
    DEVICE_MOVEMENT,       // 设备移动
    SCREEN_UNLOCK,         // 屏幕解锁
    USAGE_STATS_DENIED,    // 权限被拒
    SYSTEM_INTERRUPT       // 系统中断
}
```

#### 2.2.2 农场渲染模块
```kotlin
// 3D渲染引擎
class FarmRenderer {
    private val canvas: Canvas
    private val animals: List<Animal>
    private val background: Background
    
    fun renderFrame(deltaTime: Float)
    fun handleTouch(x: Float, y: Float)
    fun updatePhysics(deltaTime: Float)
}

// 动物实体
sealed class Animal(
    val id: String,
    val type: AnimalType,
    position: Vector2,
    velocity: Vector2
) {
    abstract fun update(deltaTime: Float, farm: Farm)
    abstract fun render(canvas: Canvas)
    abstract fun onTouch(): Boolean
}

// 动物类型和属性
enum class AnimalType(
    val displayName: String,
    val incubationTime: Long,  // 孵化所需时间（毫秒）
    val color: Color,
    val size: Float,
    val speed: Float,
    val soundResId: Int
) {
    CHICKEN("小鸡", 15 * 60 * 1000, Color.YELLOW, 30f, 50f, R.raw.chicken_sound),
    CAT("小猫", 30 * 60 * 1000, Color.ORANGE, 40f, 60f, R.raw.cat_sound),
    DOG("小狗", 60 * 60 * 1000, Color.BROWN, 50f, 70f, R.raw.dog_sound)
}
```

#### 2.2.3 AI行为系统
```kotlin
// 行为状态
sealed class BehaviorState {
    object Wandering : BehaviorState()      // 随机游走
    object Chasing : BehaviorState()         // 追逐
    object Fleeing : BehaviorState()         // 逃跑
    object Idle : BehaviorState()           // 静止
}

// AI控制器
class AnimalAI(
    private val animal: Animal,
    private val farm: Farm
) {
    private var currentState: BehaviorState = BehaviorState.Wandering
    private var targetAnimal: Animal? = null
    private var fleeTarget: Vector2? = null
    
    fun update(deltaTime: Float) {
        when (currentState) {
            is BehaviorState.Wandering -> updateWandering(deltaTime)
            is BehaviorState.Chasing -> updateChasing(deltaTime)
            is BehaviorState.Fleeing -> updateFleeing(deltaTime)
            is BehaviorState.Idle -> updateIdle(deltaTime)
        }
    }
    
    private fun updateWandering(deltaTime: Float) {
        // 使用Perlin噪声生成随机方向
        val noise = perlinNoise.getValue(animal.position.x, animal.position.y)
        val direction = Vector2(cos(noise), sin(noise))
        animal.velocity += direction * animal.type.speed * deltaTime
        animal.velocity = animal.velocity.clampMagnitude(animal.type.speed)
    }
}
```

## 3. 数据架构设计

### 3.1 数据库设计
```kotlin
// 动物实体表
@Entity(tableName = "animals")
data class AnimalEntity(
    @PrimaryKey val id: String,
    val type: String,
    val posX: Float,
    val posY: Float,
    val velX: Float,
    val velY: Float,
    val state: String,
    val createdAt: Long,
    val updatedAt: Long
)

// 孵化会话表
@Entity(tableName = "incubation_sessions")
data class IncubationSessionEntity(
    @PrimaryKey val id: String,
    val startTime: Long,
    val endTime: Long?,
    val duration: Long,
    val result: String,  // SUCCESS, INTERRUPTED, FAILED
    val mode: String,    // STRICT, NATURAL
    val interruptionReason: String?,
    val animalGenerated: String?,  // 生成的动物类型
    val createdAt: Long
)

// 周期表
@Entity(tableName = "cycles")
data class CycleEntity(
    @PrimaryKey val id: String,
    val startTime: Long,
    val endTime: Long?,
    val type: String,    // WEEK, MONTH, CUSTOM
    val totalSessions: Int,
    val totalDuration: Long,
    val animalsGenerated: Map<String, Int>,
    val achievements: List<String>,
    val createdAt: Long
)

// 成就表
@Entity(tableName = "achievements")
data class AchievementEntity(
    @PrimaryKey val id: String,
    val name: String,
    val description: String,
    val icon: String,
    val condition: String,
    val progress: Int,
    val target: Int,
    val unlockedAt: Long?,
    val createdAt: Long
)
```

### 3.2 数据访问层
```kotlin
@Dao
interface AnimalDao {
    @Query("SELECT * FROM animals WHERE state = 'ACTIVE'")
    fun getActiveAnimals(): Flow<List<AnimalEntity>>
    
    @Insert
    suspend fun insertAnimal(animal: AnimalEntity)
    
    @Update
    suspend fun updateAnimal(animal: AnimalEntity)
    
    @Query("DELETE FROM animals WHERE id = :animalId")
    suspend fun deleteAnimal(animalId: String)
}

@Dao
interface IncubationSessionDao {
    @Query("SELECT * FROM incubation_sessions ORDER BY startTime DESC LIMIT :limit")
    fun getRecentSessions(limit: Int = 100): Flow<List<IncubationSessionEntity>>
    
    @Query("SELECT * FROM incubation_sessions WHERE startTime >= :startTime AND startTime <= :endTime")
    fun getSessionsInRange(startTime: Long, endTime: Long): Flow<List<IncubationSessionEntity>>
    
    @Insert
    suspend fun insertSession(session: IncubationSessionEntity)
    
    @Update
    suspend fun updateSession(session: IncubationSessionEntity)
}
```

## 4. 状态管理架构

### 4.1 UI状态管理
```kotlin
// 主界面状态
sealed class MainUiState {
    object Loading : MainUiState()
    data class Ready(
        val timerState: TimerState,
        val animals: List<Animal>,
        val statistics: Statistics,
        val focusMode: FocusMode
    ) : MainUiState()
    data class Error(val message: String) : MainUiState()
}

// 农场界面状态
sealed class FarmUiState {
    object Loading : FarmUiState()
    data class Active(
        val animals: List<Animal>,
        val background: Background,
        val interactionEffects: List<InteractionEffect>
    ) : FarmUiState()
    data class Interaction(
        val animal: Animal,
        val effect: InteractionEffect
    ) : FarmUiState()
}

// 统计界面状态
sealed class StatisticsUiState {
    object Loading : StatisticsUiState()
    data class Ready(
        val currentCycle: Cycle,
        val historicalCycles: List<Cycle>,
        val achievements: List<Achievement>,
        val chartsData: ChartsData
    ) : StatisticsUiState()
}
```

### 4.2 ViewModel设计
```kotlin
@HiltViewModel
class MainViewModel @Inject constructor(
    private val timerManager: TimerManager,
    private val animalRepository: AnimalRepository,
    private val statisticsRepository: StatisticsRepository
) : ViewModel() {
    
    private val _uiState = MutableStateFlow<MainUiState>(MainUiState.Loading)
    val uiState: StateFlow<MainUiState> = _uiState.asStateFlow()
    
    private val _timerState = MutableStateFlow<TimerState>(TimerState.Idle)
    val timerState: StateFlow<TimerState> = _timerState.asStateFlow()
    
    init {
        loadInitialData()
        observeTimerChanges()
    }
    
    fun startFocusSession(mode: FocusMode) {
        viewModelScope.launch {
            timerManager.startTimer(mode)
        }
    }
    
    fun stopFocusSession() {
        viewModelScope.launch {
            timerManager.stopTimer()
        }
    }
    
    private fun observeTimerChanges() {
        timerManager.timerState
            .onEach { state ->
                _timerState.value = state
                updateUiState()
            }
            .launchIn(viewModelScope)
    }
}
```

## 5. 通知和前台服务架构

### 5.1 前台服务设计
```kotlin
class FocusTimerService : LifecycleService() {
    private lateinit var notificationManager: NotificationManagerCompat
    private lateinit var timerManager: TimerManager
    private lateinit var interruptionDetector: InterruptionDetector
    
    override fun onCreate() {
        super.onCreate()
        initializeComponents()
        startForeground(NOTIFICATION_ID, createNotification())
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        super.onStartCommand(intent, flags, startId)
        
        when (intent?.action) {
            ACTION_START_TIMER -> startTimer()
            ACTION_STOP_TIMER -> stopTimer()
            ACTION_UPDATE_NOTIFICATION -> updateNotification()
        }
        
        return START_STICKY
    }
    
    private fun createNotification(): Notification {
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("专注农场")
            .setContentText("专注计时进行中...")
            .setSmallIcon(R.drawable.ic_notification)
            .setOngoing(true)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()
    }
    
    companion object {
        private const val NOTIFICATION_ID = 1001
        private const val CHANNEL_ID = "focus_timer_channel"
        
        const val ACTION_START_TIMER = "START_TIMER"
        const val ACTION_STOP_TIMER = "STOP_TIMER"
        const val ACTION_UPDATE_NOTIFICATION = "UPDATE_NOTIFICATION"
    }
}
```

### 5.2 通知渠道管理
```kotlin
class NotificationChannelManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    fun createNotificationChannels() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channels = listOf(
                NotificationChannel(
                    FOCUS_TIMER_CHANNEL_ID,
                    "专注计时",
                    NotificationManager.IMPORTANCE_LOW
                ).apply {
                    description = "专注计时通知"
                    setShowBadge(false)
                    enableVibration(false)
                    enableSound(false)
                },
                
                NotificationChannel(
                    ACHIEVEMENT_CHANNEL_ID,
                    "成就提醒",
                    NotificationManager.IMPORTANCE_DEFAULT
                ).apply {
                    description = "成就解锁通知"
                    setShowBadge(true)
                    enableVibration(true)
                }
            )
            
            val notificationManager = context.getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannels(channels)
        }
    }
}
```

## 6. 性能优化策略

### 6.1 渲染优化
```kotlin
// 帧率控制
class FrameRateController(
    private val targetFps: Int = 60
) {
    private val frameInterval = 1000L / targetFps
    private var lastFrameTime = 0L
    
    fun shouldRenderFrame(currentTime: Long): Boolean {
        return currentTime - lastFrameTime >= frameInterval
    }
    
    fun markFrameRendered(currentTime: Long) {
        lastFrameTime = currentTime
    }
}

// 对象池管理
class AnimalPool {
    private val pool = mutableListOf<Animal>()
    private val maxSize = 50
    
    fun acquire(type: AnimalType): Animal {
        return pool.find { it.type == type && !it.isActive } 
            ?: createNewAnimal(type)
    }
    
    fun release(animal: Animal) {
        if (pool.size < maxSize) {
            animal.reset()
            pool.add(animal)
        }
    }
}
```

### 6.2 内存管理
```kotlin
// 资源管理器
class ResourceManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    private val bitmapCache = LruCache<String, Bitmap>(calculateMemoryCacheSize())
    private val soundPool = SoundPool.Builder()
        .setMaxStreams(5)
        .build()
    
    fun loadBitmap(key: String, resId: Int): Bitmap {
        return bitmapCache.get(key) ?: run {
            val bitmap = BitmapFactory.decodeResource(context.resources, resId)
            bitmapCache.put(key, bitmap)
            bitmap
        }
    }
    
    fun loadSound(soundResId: Int): Int {
        return soundPool.load(context, soundResId, 1)
    }
    
    fun playSound(soundId: Int) {
        soundPool.play(soundId, 1f, 1f, 1, 0, 1f)
    }
    
    fun release() {
        bitmapCache.evictAll()
        soundPool.release()
    }
}
```

## 7. 错误处理和监控

### 7.1 异常处理
```kotlin
// 全局异常处理器
class GlobalExceptionHandler : Thread.UncaughtExceptionHandler {
    private val defaultHandler = Thread.getDefaultUncaughtExceptionHandler()
    
    override fun uncaughtException(thread: Thread, throwable: Throwable) {
        // 记录崩溃信息
        logCrash(throwable)
        
        // 保存当前状态
        saveAppState()
        
        // 调用默认处理器
        defaultHandler?.uncaughtException(thread, throwable)
    }
    
    private fun logCrash(throwable: Throwable) {
        val crashInfo = CrashInfo(
            timestamp = System.currentTimeMillis(),
            message = throwable.message ?: "Unknown error",
            stackTrace = throwable.stackTraceToString(),
            deviceInfo = getDeviceInfo()
        )
        
        // 保存到本地数据库
        GlobalScope.launch {
            crashRepository.saveCrash(crashInfo)
        }
    }
}
```

### 7.2 性能监控
```kotlin
// 性能监控器
class PerformanceMonitor {
    private val frameTimeBuffer = CircularBuffer<Long>(100)
    private var lastFrameTime = 0L
    
    fun recordFrameTime(currentTime: Long) {
        if (lastFrameTime != 0L) {
            val frameTime = currentTime - lastFrameTime
            frameTimeBuffer.add(frameTime)
        }
        lastFrameTime = currentTime
    }
    
    fun getAverageFrameTime(): Long {
        return frameTimeBuffer.average().toLong()
    }
    
    fun getFps(): Float {
        val avgFrameTime = getAverageFrameTime()
        return if (avgFrameTime > 0) 1000f / avgFrameTime else 0f
    }
}
```

## 8. 安全设计

### 8.1 数据安全
```kotlin
// 数据加密
class DataEncryption @Inject constructor() {
    private val cipher = Cipher.getInstance("AES/GCM/NoPadding")
    private val secretKey = generateSecretKey()
    
    fun encrypt(data: String): EncryptedData {
        val iv = ByteArray(12) // GCM推荐的IV长度
        SecureRandom().nextBytes(iv)
        
        cipher.init(Cipher.ENCRYPT_MODE, secretKey, GCMParameterSpec(128, iv))
        val encryptedBytes = cipher.doFinal(data.toByteArray())
        
        return EncryptedData(encryptedBytes, iv)
    }
    
    fun decrypt(encryptedData: EncryptedData): String {
        cipher.init(Cipher.DECRYPT_MODE, secretKey, GCMParameterSpec(128, encryptedData.iv))
        val decryptedBytes = cipher.doFinal(encryptedData.data)
        return String(decryptedBytes)
    }
}
```

### 8.2 权限安全
```kotlin
// 权限验证器
class PermissionValidator @Inject constructor(
    @ApplicationContext private val context: Context
) {
    fun validateUsageStatsPermission(): Boolean {
        val appOpsManager = context.getSystemService(Context.APP_OPS_SERVICE) as AppOpsManager
        val mode = appOpsManager.checkOpNoThrow(
            AppOpsManager.OPSTR_GET_USAGE_STATS,
            Process.myUid(),
            context.packageName
        )
        return mode == AppOpsManager.MODE_ALLOWED
    }
    
    fun validateAllRequiredPermissions(): Map<String, Boolean> {
        return mapOf(
            "usage_stats" to validateUsageStatsPermission(),
            "foreground_service" to hasPermission(Manifest.permission.FOREGROUND_SERVICE),
            "wake_lock" to hasPermission(Manifest.permission.WAKE_LOCK),
            "post_notifications" to hasNotificationPermission()
        )
    }
}
```